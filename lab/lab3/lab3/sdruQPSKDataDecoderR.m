classdef sdruQPSKDataDecoderR < matlab.System
%#codegen
% Copyright 2012 The MathWorks, Inc.
 
 properties (Nontunable)
 FrameSize
 BarkerLength
 ModulationOrder
 DataLength
 MessageLength
 DescramblerBase
 DescramblerPolynomial
 DescramblerInitialConditions
 PrintOption
 end
 
 properties (Access=private)
 pCount
 pDelay
 pPhase
 pBuffer
 pModulator
 pModulatedHeader
 pCorrelator
 pQPSKDemodulator
 pDescrambler
 pBitGenerator
 pBitGeneratorSync
 pBER
 pSyncFlag
 pSyncIndex
 pFrameIndex
 end
 
 
 methods
 function obj = sdruQPSKDataDecoderR(varargin)
 setProperties(obj,nargin,varargin{:});
 end
 end
 
 methods (Access=protected)
 function setupImpl(obj, ~)
 [obj.pCount, obj.pDelay, obj.pPhase] = deal(0);
 obj.pFrameIndex=1;
 obj.pSyncIndex=0;
 obj.pSyncFlag=true;
 obj.pBuffer=dsp.Buffer(obj.FrameSize*2, obj.FrameSize);
 bbc = [+1 +1 +1 +1 +1 -1 -1 +1 +1 -1 +1 -1 +1 +1 +1 +1 +1 +1 -1 -1 +1 +1 -1 +1 -1 +1]; % Bipolar Barker Code
 ubc = ((bbc + 1) / 2)'; % Unipolar Barker Code
 header = (repmat(ubc,1,2))';
 header = header(:);
 
% obj.pModulator = comm.QPSKModulator('BitInput', true, ...
% 'PhaseOffset', pi/4);
 
 obj.pModulator = comm.RectangularQAMModulator(16, 'BitInput',true,...
 'NormalizationMethod','Average power',...
 'SymbolMapping', 'Custom', ...
 'CustomSymbolMapping', [11 10 14 15 9 8 12 13 1 0 4 5 3 2 6 7]);
 obj.pModulatedHeader = step(obj.pModulator, header); % Modulate the header
 obj.pCorrelator = dsp.Crosscorrelator;
 %obj.pQPSKDemodulator = comm.QPSKDemodulator('PhaseOffset',pi/4, ...
 % 'BitOutput', true);
 obj.pQPSKDemodulator = comm.RectangularQAMDemodulator(...
 'ModulationOrder', 16, ...
 'BitOutput', true, ...
 'NormalizationMethod', 'Average power', 'SymbolMapping', 'Custom', ...
 'CustomSymbolMapping', [11 10 14 15 9 8 12 13 1 0 4 5 3 2 6 7]);
 
 obj.pDescrambler = comm.Descrambler(obj.DescramblerBase, ...
 obj.DescramblerPolynomial, obj.DescramblerInitialConditions);
 obj.pBER = comm.ErrorRate;
 end
 
 function BER = stepImpl(obj, DataIn)
 % Buffer one frame in case that contiguous data scatter across
 % two adjacent frames
 rxData = step(obj.pBuffer,DataIn);
 
 % Get a frame of data aligned on the frame boundary
 Data = rxData(obj.pDelay+1:obj.pDelay+length(rxData)/2);
 
 % Phase estimation
 y = mean(conj(obj.pModulatedHeader) .* Data(1:obj.BarkerLength));
 
 % Compensating for the phase offset
 if Data(1)~=0
 phShiftedData = Data .* exp(-1j*obj.pPhase);
 else
 phShiftedData = complex(zeros(size(Data)));
 end
 % Demodulate the phase recovered data
 demodOut = step(obj.pQPSKDemodulator, phShiftedData);
 
 % Perform descrambling
 deScrData = step(obj.pDescrambler, ...
 demodOut( ...
 obj.BarkerLength*log2(obj.ModulationOrder)+1 : ...
 obj.FrameSize*log2(obj.ModulationOrder)));
 
 % Recovering the message from the data
 Received = deScrData(1:obj.MessageLength);
 
 % Finding the delay to achieve frame synchronization
 z=abs(step(obj.pCorrelator,obj.pModulatedHeader,DataIn));
 [~, ind] = max(z);
 obj.pDelay = mod(length(DataIn)-ind,(length(DataIn)-1));
 
 % Phase ambiguity correction
 obj.pPhase = round(angle(y)*2/pi)/2*pi;
 
 % Print received frame and estimate the received frame index
 [estimatedFrameIndex,syncIndex]=bits2ASCII(obj,Received);
 obj.pSyncIndex = syncIndex;
 % Once it is possible to decode the frame index four times,
 % frame synchronization is achieved
 if ((obj.pSyncFlag) && (estimatedFrameIndex~=100) && (obj.pSyncIndex>=4))
 obj.pFrameIndex=estimatedFrameIndex;
 obj.pSyncFlag=false;
 end
 % With the estimated frame index, estimate the transmitted
 % message
 transmittedMessage=messEstimator(obj.pFrameIndex, obj);
 % Calculate the BER
 BER = step(obj.pBER,transmittedMessage,Received);
 obj.pCount = obj.pCount + 1;
 obj.pFrameIndex = obj.pFrameIndex + 1;
 end
 
 function resetImpl(obj)
 reset(obj.pBuffer);
 end
 
 function releaseImpl(obj)
 release(obj.pBuffer);
 end
 
 end
 
 methods (Access=private)
 function [estimatedFrameIndex,syncIndex]=bits2ASCII(obj,u)
 coder.extrinsic('disp')
 
 % Convert binary-valued column vector to 7-bit decimal values.
 w = [64 32 16 8 4 2 1]; % binary digit weighting
 Nbits = numel(u);
 Ny = Nbits/7;
 y = zeros(1,Ny);
 % Obtain ASCII values of received frame
 for i = 0:Ny-1
 y(i+1) = w*u(7*i+(1:7));
 end
 
 % Display ASCII message to command window 
 if(obj.PrintOption)
 disp(char(y));
 end
 % Retrieve last 2 ASCII values
 decodedNumber=y(Ny-1:end);
 % Create lookup table of ASCII values and corresponding integer numbers 
 look_tab=zeros(2,10);
 look_tab(1,:)=0:9;
 look_tab(2,:)=48:57;
 % Initialize variables
 estimatedFrameIndex=100;
 syncIndex=0;
 onesPlace=0;
 tensPlace=0;
 dec_found=false;
 unity_found=false;
 
 % Index lookup table with decoded ASCII values
 % There are more efficient ways to perform vector indexing
 % using MATLAB functions like find(). However, to meet codegen
 % requirements, the usage of the four loop was necessary.
 
 for ii=1:10
 % Find the ones place in the lookup table
 if ( decodedNumber(1) == look_tab(2,ii) )
 onesPlace=10*look_tab(1,ii);
 dec_found=true;
 end
 % Find the tens place in the lookup table
 if ( decodedNumber(2) == look_tab(2,ii) )
 tensPlace=look_tab(1,ii);
 unity_found=true;
 end
 end
 % Estimate the frame index
 if(dec_found && unity_found && obj.pSyncFlag)
 estimatedFrameIndex=onesPlace+tensPlace;
 syncIndex=obj.pSyncIndex+1;
 end
 
 
 end
 
 function msg = messEstimator(ind, obj)
 
 MsgStrSet = ['Hello world 1000';...
 'Hello world 1001';...
 'Hello world 1002';...
 'Hello world 1003';...
 'Hello world 1004';...
 'Hello world 1005';...
 'Hello world 1006';...
 'Hello world 1007';...
 'Hello world 1008';...
 'Hello world 1009';...
 'Hello world 1010';...
 'Hello world 1011';...
 'Hello world 1012';...
 'Hello world 1013';...
 'Hello world 1014';...
 'Hello world 1015';...
 'Hello world 1016';...
 'Hello world 1017';...
 'Hello world 1018';...
 'Hello world 1019';...
 'Hello world 1020';...
 'Hello world 1021';...
 'Hello world 1022';...
 'Hello world 1023';...
 'Hello world 1024';...
 'Hello world 1025';...
 'Hello world 1026';...
 'Hello world 1027';...
 'Hello world 1028';...
 'Hello world 1029';...
 'Hello world 1030';...
 'Hello world 1031';...
 'Hello world 1032';...
 'Hello world 1033';...
 'Hello world 1034';...
 'Hello world 1035';...
 'Hello world 1036';...
 'Hello world 1037';...
 'Hello world 1038';...
 'Hello world 1039';...
 'Hello world 1040';...
 'Hello world 1041';...
 'Hello world 1042';...
 'Hello world 1043';...
 'Hello world 1044';...
 'Hello world 1045';...
 'Hello world 1046';...
 'Hello world 1047';...
 'Hello world 1048';...
 'Hello world 1049';...
 'Hello world 1050';...
 'Hello world 1051';...
 'Hello world 1052';...
 'Hello world 1053';...
 'Hello world 1054';...
 'Hello world 1055';...
 'Hello world 1056';...
 'Hello world 1057';...
 'Hello world 1058';...
 'Hello world 1059';...
 'Hello world 1060';...
 'Hello world 1061';...
 'Hello world 1062';...
 'Hello world 1063';...
 'Hello world 1064';...
 'Hello world 1065';...
 'Hello world 1066';...
 'Hello world 1067';...
 'Hello world 1068';...
 'Hello world 1069';...
 'Hello world 1070';...
 'Hello world 1071';...
 'Hello world 1072';...
 'Hello world 1073';...
 'Hello world 1074';...
 'Hello world 1075';...
 'Hello world 1076';...
 'Hello world 1077';...
 'Hello world 1078';...
 'Hello world 1079';...
 'Hello world 1080';...
 'Hello world 1081';...
 'Hello world 1082';...
 'Hello world 1083';...
 'Hello world 1084';...
 'Hello world 1085';...
 'Hello world 1086';...
 'Hello world 1087';...
 'Hello world 1088';...
 'Hello world 1089';...
 'Hello world 1090';...
 'Hello world 1091';...
 'Hello world 1092';...
 'Hello world 1093';...
 'Hello world 1094';...
 'Hello world 1095';...
 'Hello world 1096';...
 'Hello world 1097';...
 'Hello world 1098';...
 'Hello world 1099'];
 cycle = mod(ind,100);
 msgStr = MsgStrSet(cycle+1,:);
 msgBin = de2bi(int8(msgStr),7,'left-msb');
 msg = reshape(double(msgBin).',obj.MessageLength,1);
 end
 
 
 end
end